/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package simplevm;

import java.util.Map;
import java.util.HashMap;

class Bytecode {
    public static final int NOP = 0;
    public static final int HALT = 1;
    public static final int DUMP = 2;
    public static final int PRINT = 3;

    public static final int CONST = 10;
    public static final int LDC = 11;

    public static final int ADD = 20;
    public static final int SUB = 21;
    public static final int MUL = 22;
    public static final int DIV = 23;
    public static final int MOD = 24;

    public static final int EQ = 40;
    public static final int NE = 41;
    public static final int LT = 42;
    public static final int GT = 43;
    public static final int LTE = 44;
    public static final int GTE = 45;

    public static final int JMP = 50;
    public static final int JT = 51;
    public static final int JF = 52;

    public static final int GSTORE = 30;
    public static final int GLOAD = 31;

    public static String disassemble(int[] code) {
        String result = "";
        for (int i=0; i<code.length; i++) {
            result += String.format("%04d: ", i);
            switch (code[i]) {
                case NOP: result += "NOP"; break;
                case DUMP: result += "DUMP"; break;
                case PRINT: result += "PRINT"; break;

                case CONST: result += "CONST " + code[++i]; break;
                case LDC: result += "LDC " + code[++i]; break;
                //case POP: result += "POP"; break;

                case ADD: result += "ADD"; break;
                case SUB: result += "SUB"; break;
                case MUL: result += "MUL"; break;
                case DIV: result += "DIV"; break;
                case MOD: result += "MOD"; break;

                case EQ: result += "EQ"; break;
                case NE: result += "NE"; break;
                case LT: result += "LT"; break;
                case LTE: result += "LTE"; break;
                case GT: result += "GT"; break;
                case GTE: result += "GTE"; break;

                case GSTORE: result += "GSTORE " + code[++i]; break;
                case GLOAD: result += "GLOAD " + code[++i]; break;
                //case LSTORE: result += "LSTORE " + code[++i]; break;
                //case LLOAD: result += "LLOAD " + code[++i]; break;

                case JMP: result += "JMP " + code[++i]; break;
                case JT: result += "JT " + code[++i]; break;
                case JF: result += "JF " + code[++i]; break;

                //case CALL: result += "CALL " + code[++i]; break;
                //case CALLI: result += "CALLI"; break;
                //case RET: result += "RET"; break;

                default: result += "?" + code[i] + "?"; break;
            }
            result += "\n";
        }
        return result;
    }
}

public class App {
    boolean trace = false;

    Map<Integer, Object> constantPool = new HashMap<>();

    int[] code;
    int ip = -1;

    Object[] stack = new Object[100];
    int sp = -1;

    Object[] memory = new Object[100];

    public void push(Object it) { stack[++sp] = it; }
    public Object pop() { return stack[sp--]; }
    public int fetch() { return code[++ip]; }

    void execute() {
        while (ip < code.length) {
            int opcode = fetch();
            switch (opcode) {
                case Bytecode.NOP:
                    if (trace)
                        System.out.println("NOP");
                    // Do nothing!
                    break;
                
                case Bytecode.HALT: {
                    if (trace)
                        System.out.println("NOP");
                    throw new RuntimeException("HALT executed");
                }

                case Bytecode.PRINT: {
                    Object printed = pop();
                    System.out.println(">>> " + printed);
                    break;
                }

                case Bytecode.CONST: {
                    int constant = fetch();
                    if (trace)
                        System.out.println("CONST " + constant);
                    push(constant);
                    break;
                }
                case Bytecode.LDC: {
                    int index = fetch();
                    Object constant = constantPool.get(index);
                    if (trace)
                        System.out.println("LDC " + constant);
                    push(constant);
                    break;
                }

                case Bytecode.GSTORE: {
                    int index = fetch();
                    Object value = pop();
                    memory[index] = value;
                    break;
                }
                case Bytecode.GLOAD: {
                    int index = fetch();
                    Object value = memory[index];
                    push(value);
                    break;
                }

                case Bytecode.ADD:
                case Bytecode.SUB:
                case Bytecode.MUL:
                case Bytecode.DIV:
                case Bytecode.MOD:
                {
                    int rhs = (int)pop();
                    int lhs = (int)pop();
                    int result = 0;
                    switch (opcode) {
                        case Bytecode.ADD: result = lhs + rhs; break;
                        case Bytecode.SUB: result = lhs - rhs; break;
                        case Bytecode.MUL: result = lhs * rhs; break;
                        case Bytecode.DIV: result = lhs / rhs; break;
                        case Bytecode.MOD: result = lhs % rhs; break;
                    }
                    if (trace)
                        System.out.println("MATH " + lhs + " " + rhs + " = " + result);
                    push(result);
                    break;
                }
                
                case Bytecode.EQ: 
                case Bytecode.NE: 
                case Bytecode.LT: 
                case Bytecode.LTE: 
                case Bytecode.GT: 
                case Bytecode.GTE:
                {
                    int rhs = (int)pop();
                    int lhs = (int)pop();
                    int result = 0;
                    switch (opcode) {
                        case Bytecode.EQ: result = (lhs == rhs ? 1 : 0); break;
                        case Bytecode.NE: result = (lhs != rhs ? 1 : 0); break;
                        case Bytecode.LT: result = (lhs < rhs ? 1 : 0); break;
                        case Bytecode.LTE: result = (lhs <= rhs ? 1 : 0); break;
                        case Bytecode.GT: result = (lhs > rhs ? 1 : 0); break;
                        case Bytecode.GTE: result = (lhs >= rhs ? 1 : 0); break;
                    }
                    push(result);
                    break;
                }

                case Bytecode.JMP: {
                    int target = fetch();
                    ip = target;
                    break;
                }

                default: {
                    System.out.println("Unrecognized opcode: " + opcode);
                }
            }
        }
    }

    public static void main(String[] args) {
        App a = new App();
        a.trace = true;
        a.constantPool.put(0, 2);
        a.constantPool.put(1, 3);
        a.code = new int[] {
            Bytecode.LDC, 0,
            Bytecode.LDC, 1,
            Bytecode.ADD,
            Bytecode.GSTORE, 0,
            Bytecode.CONST, 6,
            Bytecode.CONST, 12,
            Bytecode.ADD,            
            Bytecode.PRINT,
            Bytecode.GLOAD, 0,
            Bytecode.PRINT
        };
        a.execute();
    }
}
